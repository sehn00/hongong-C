#include "gpio.h"

void gpio_pin_set(GPIO_TypeDef *port, uint32_t pin)
{
    port->BSRR = (1U << pin);   // 해당하는 pin만 set으로 설정한다!
}
// (예) pin=5 set 하려면
// 1U = 0b0000 0000 0000 0000 0000 0000 0000 0001 에 LSL #5,
// 즉, 0b0000 0000 0000 0000 0000 0000 0010 0000 = 0x0000 0020 이 된다

void gpio_pin_reset(GPIO_TypeDef *port, uint32_t pin)
{
    port->BSRR = (1U << (pin + 16U));
}
// (예) pin=5 reset 하려면
// 1U = 0b0000 0000 0000 0000 0000 0000 0000 0001 에 LSL #21,
// 즉, 0b0000 0010 0000 0000 0000 0000 0000 0000 = 0x0020 0000 이 된다

/* STM32 기준, BSRR 레지스터는 32bit
- 하위 16bit(0~15): 1 이면 set (HIGH)
- 상위 16bit(16-31): 1 이면 reset (LOW)
- 1U = 0b0000 0000 0000 0000 0000 0000 0000 0001
*/


// <<< 번외: 헤더파일과 라이브러리 구조 >>>
// gpio.c 에서 정의한 함수의 프로토타입을 gpio.h 에 작성하는데 (gpio.c -> gpio.h)
// gpio.c 에서 #include "gpio.h" 를 해야하냐? (gpio.h -> gpio.c)
// =>
// - gpio.h 가 중심 허브
// - gpio.c 와 main.c 는 둘 다 gpio.h 를 #include
// - gpio.c 는 "선언을 보고 구현"
// - main.c 는 "선언을 보고 호출"
// - 즉, 양방향이 아니라, 공통 헤더를 공유하는 단방향 구조이다! (gpio.h -> gpio.c)
//
//           +----------------+
//           |   gpio.h       |
//           | (선언/정의)     |
//           | 함수 프로토타입  |
//           | 구조체, 매크로   |
//           +----------------+
//              ^          ^
//              |          |
//    include   |          |  include
//              |          |
// +---------------+   +---------------+
// |   gpio.c      |   |   main.c      |
// | (구현부)       |   | (사용부)       |
// | 함수 실제 코드  |   | 함수 호출 코드  |
// +---------------+   +---------------+
